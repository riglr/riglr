//! High-Frequency Trading Bot Example
//!
//! Demonstrates a production-grade HFT bot using real-time price streams and advanced processing.
//! This example shows how to:
//! - Process high-frequency price data with minimal latency
//! - Implement sophisticated trading strategies
//! - Handle backpressure and flow control
//! - Use stateful processing for position tracking
//! - Implement risk management controls

use anyhow::Result;
use riglr_core::{ToolError, ToolResult};
use riglr_events_core::prelude::*;
use riglr_showcase::config::Config;
use riglr_streams::prelude::*;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use tokio::time::{Duration, Instant};
use tracing::{info, debug, warn, error};
use serde::{Serialize, Deserialize};

/// Trading position information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub symbol: String,
    pub size: f64,
    pub entry_price: f64,
    pub current_price: f64,
    pub unrealized_pnl: f64,
    pub entry_time: Instant,
    pub last_update: Instant,
}

/// Trading signal generated by strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingSignal {
    pub symbol: String,
    pub action: TradeAction,
    pub size: f64,
    pub price: f64,
    pub confidence: f64,
    pub strategy: String,
    pub timestamp: Instant,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TradeAction {
    Buy,
    Sell,
    Hold,
}

/// Risk management parameters
#[derive(Debug, Clone)]
pub struct RiskLimits {
    pub max_position_size: f64,
    pub max_drawdown: f64,
    pub max_leverage: f64,
    pub stop_loss_pct: f64,
    pub take_profit_pct: f64,
    pub daily_loss_limit: f64,
}

impl Default for RiskLimits {
    fn default() -> Self {
        Self {
            max_position_size: 10_000.0,
            max_drawdown: 0.05, // 5%
            max_leverage: 3.0,
            stop_loss_pct: 0.02, // 2%
            take_profit_pct: 0.06, // 6%
            daily_loss_limit: 1_000.0,
        }
    }
}

/// High-frequency trading bot with advanced processing
pub struct HFTBot {
    /// Position tracking with stateful processor
    position_processor: StatefulProcessor<String, Position>,

    /// Price data window manager for technical analysis
    price_windows: WindowManager<PriceUpdate>,

    /// Flow controller for handling high-frequency data
    flow_controller: FlowController,

    /// Trading strategies
    strategies: Vec<Box<dyn TradingStrategy>>,

    /// Risk management system
    risk_manager: RiskManager,

    /// Performance metrics
    metrics: Arc<RwLock<TradingMetrics>>,

    /// Configuration
    config: HFTConfig,
}

#[derive(Debug, Clone)]
pub struct HFTConfig {
    pub risk_limits: RiskLimits,
    pub min_order_size: f64,
    pub max_orders_per_second: u32,
    pub price_precision: u8,
    pub enable_paper_trading: bool,
}

impl Default for HFTConfig {
    fn default() -> Self {
        Self {
            risk_limits: RiskLimits::default(),
            min_order_size: 10.0,
            max_orders_per_second: 100,
            price_precision: 6,
            enable_paper_trading: true,
        }
    }
}

#[derive(Debug, Clone)]
pub struct PriceUpdate {
    pub symbol: String,
    pub price: f64,
    pub volume: f64,
    pub timestamp: Instant,
    pub bid: Option<f64>,
    pub ask: Option<f64>,
    pub spread: Option<f64>,
}

/// Trading performance metrics
#[derive(Debug, Default)]
pub struct TradingMetrics {
    pub total_trades: u64,
    pub profitable_trades: u64,
    pub total_pnl: f64,
    pub max_drawdown: f64,
    pub win_rate: f64,
    pub avg_trade_duration: Duration,
    pub sharpe_ratio: f64,
    pub processed_events: u64,
    pub latency_stats: LatencyStats,
}

#[derive(Debug, Default)]
pub struct LatencyStats {
    pub min_latency_ms: f64,
    pub max_latency_ms: f64,
    pub avg_latency_ms: f64,
    pub p95_latency_ms: f64,
    pub p99_latency_ms: f64,
}

/// Trading strategy trait
trait TradingStrategy: Send + Sync {
    fn name(&self) -> &str;
    fn generate_signal(&self, price_data: &[PriceUpdate], positions: &HashMap<String, Position>) -> Option<TradingSignal>;
    fn update_parameters(&mut self, performance: &TradingMetrics);
}

/// Mean reversion trading strategy
pub struct MeanReversionStrategy {
    lookback_period: usize,
    z_score_threshold: f64,
    min_confidence: f64,
}

impl MeanReversionStrategy {
    pub fn new(lookback_period: usize, z_score_threshold: f64) -> Self {
        Self {
            lookback_period,
            z_score_threshold,
            min_confidence: 0.6,
        }
    }

    fn calculate_z_score(&self, prices: &[f64]) -> Option<f64> {
        if prices.len() < self.lookback_period {
            return None;
        }

        let recent_prices = &prices[prices.len() - self.lookback_period..];
        let mean: f64 = recent_prices.iter().sum::<f64>() / recent_prices.len() as f64;
        let variance: f64 = recent_prices.iter()
            .map(|price| (price - mean).powi(2))
            .sum::<f64>() / recent_prices.len() as f64;

        let std_dev = variance.sqrt();
        if std_dev == 0.0 {
            return None;
        }

        let current_price = *recent_prices.last()?;
        Some((current_price - mean) / std_dev)
    }
}

impl TradingStrategy for MeanReversionStrategy {
    fn name(&self) -> &str {
        "MeanReversion"
    }

    fn generate_signal(&self, price_data: &[PriceUpdate], positions: &HashMap<String, Position>) -> Option<TradingSignal> {
        if price_data.is_empty() {
            return None;
        }

        let symbol = &price_data[0].symbol;
        let prices: Vec<f64> = price_data.iter().map(|p| p.price).collect();
        let z_score = self.calculate_z_score(&prices)?;

        // Generate signals based on z-score
        if z_score > self.z_score_threshold {
            // Price is too high, sell signal
            let confidence = (z_score / self.z_score_threshold).min(1.0);
            if confidence >= self.min_confidence {
                return Some(TradingSignal {
                    symbol: symbol.clone(),
                    action: TradeAction::Sell,
                    size: 100.0,
                    price: price_data.last()?.price,
                    confidence,
                    strategy: self.name().to_string(),
                    timestamp: Instant::now(),
                });
            }
        } else if z_score < -self.z_score_threshold {
            // Price is too low, buy signal
            let confidence = (-z_score / self.z_score_threshold).min(1.0);
            if confidence >= self.min_confidence {
                return Some(TradingSignal {
                    symbol: symbol.clone(),
                    action: TradeAction::Buy,
                    size: 100.0,
                    price: price_data.last()?.price,
                    confidence,
                    strategy: self.name().to_string(),
                    timestamp: Instant::now(),
                });
            }
        }

        None
    }

    fn update_parameters(&mut self, performance: &TradingMetrics) {
        // Adaptive parameter adjustment based on performance
        if performance.win_rate < 0.4 {
            // Increase threshold to be more selective
            self.z_score_threshold = (self.z_score_threshold * 1.1).min(3.0);
        } else if performance.win_rate > 0.7 {
            // Decrease threshold to capture more opportunities
            self.z_score_threshold = (self.z_score_threshold * 0.95).max(1.5);
        }

        debug!("🔧 {} strategy updated: threshold={:.2}, win_rate={:.2}%",
               self.name(), self.z_score_threshold, performance.win_rate * 100.0);
    }
}

/// Risk management system
pub struct RiskManager {
    limits: RiskLimits,
    daily_pnl: Arc<Mutex<f64>>,
    max_drawdown_today: Arc<Mutex<f64>>,
}

impl RiskManager {
    pub fn new(limits: RiskLimits) -> Self {
        Self {
            limits,
            daily_pnl: Arc::new(Mutex::new(0.0)),
            max_drawdown_today: Arc::new(Mutex::new(0.0)),
        }
    }

    pub async fn validate_trade(&self, signal: &TradingSignal, positions: &HashMap<String, Position>) -> bool {
        // Check daily loss limit
        let daily_pnl = *self.daily_pnl.lock().await;
        if daily_pnl < -self.limits.daily_loss_limit {
            warn!("🚨 Daily loss limit exceeded: ${:.2}", daily_pnl);
            return false;
        }

        // Check position size limits
        if signal.size > self.limits.max_position_size {
            warn!("🚨 Position size too large: {:.2} > {:.2}", signal.size, self.limits.max_position_size);
            return false;
        }

        // Check existing position and leverage
        if let Some(existing_position) = positions.get(&signal.symbol) {
            let total_exposure = existing_position.size.abs() + signal.size;
            if total_exposure > self.limits.max_position_size * self.limits.max_leverage {
                warn!("🚨 Leverage limit exceeded for {}: {:.2}", signal.symbol, total_exposure);
                return false;
            }
        }

        true
    }

    pub async fn update_daily_pnl(&self, pnl_change: f64) {
        let mut daily_pnl = self.daily_pnl.lock().await;
        *daily_pnl += pnl_change;

        let mut max_drawdown = self.max_drawdown_today.lock().await;
        if *daily_pnl < *max_drawdown {
            *max_drawdown = *daily_pnl;
        }
    }
}

impl HFTBot {
    pub fn new(config: HFTConfig) -> Self {
        // Create stateful processor for position tracking
        let position_processor = StatefulProcessor::new(Duration::from_secs(10));

        // Create price window manager for 1-second windows
        let price_windows = WindowManager::new(
            WindowType::Sliding {
                size: Duration::from_secs(60), // 1-minute sliding window
                step: Duration::from_secs(1),  // Update every second
            }
        );

        // Create flow controller with adaptive backpressure
        let flow_config = BackpressureConfig {
            channel_size: 10_000,
            strategy: BackpressureStrategy::Adaptive,
            high_watermark_pct: 90,
            low_watermark_pct: 10,
        };
        let flow_controller = FlowController::new(flow_config);

        // Create trading strategies
        let strategies: Vec<Box<dyn TradingStrategy>> = vec![
            Box::new(MeanReversionStrategy::new(20, 2.0)),
        ];

        // Create risk manager
        let risk_manager = RiskManager::new(config.risk_limits.clone());

        Self {
            position_processor,
            price_windows,
            flow_controller,
            strategies,
            risk_manager,
            metrics: Arc::new(RwLock::new(TradingMetrics::default())),
            config,
        }
    }

    pub async fn process_price_event(&mut self, price_event: PriceUpdate) -> ToolResult<()> {
        let start_time = Instant::now();

        // Apply flow control
        self.flow_controller.acquire_permit().await
            .map_err(|e| ToolError::permanent_string(format!("Flow control error: {}", e)))?;

        // Update metrics
        {
            let mut metrics = self.metrics.write().await;
            metrics.processed_events += 1;
        }

        // Add price to sliding windows
        let completed_windows = self.price_windows.add_event(price_event.clone());

        // Process completed windows for trading signals
        for window in completed_windows {
            if window.events.is_empty() {
                continue;
            }

            debug!("📊 Processing price window for {} with {} data points",
                   price_event.symbol, window.events.len());

            // Get current positions
            let current_positions = self.get_current_positions().await;

            // Generate trading signals from strategies
            for strategy in &self.strategies {
                if let Some(signal) = strategy.generate_signal(&window.events, &current_positions) {
                    info!("⚡ Generated signal: {:?}", signal);

                    // Validate signal through risk management
                    if self.risk_manager.validate_trade(&signal, &current_positions).await {
                        // Execute trade (or simulate in paper trading mode)
                        self.execute_trade(signal).await?;
                    } else {
                        warn!("🚨 Signal rejected by risk management: {:?}", signal);
                    }
                }
            }
        }

        // Update position with latest price
        self.update_position_price(price_event.symbol.clone(), price_event.price).await?;

        // Release flow control permit
        self.flow_controller.release_permit().await;

        // Update latency metrics
        let processing_time = start_time.elapsed();
        self.update_latency_metrics(processing_time.as_secs_f64() * 1000.0).await;

        Ok(())
    }

    async fn get_current_positions(&self) -> HashMap<String, Position> {
        // This would typically query the position processor state
        // For this example, we'll return an empty map
        HashMap::new()
    }

    async fn update_position_price(&self, symbol: String, price: f64) -> ToolResult<()> {
        self.position_processor.update_state(symbol, |current_position| {
            let mut position = current_position.cloned().unwrap_or(Position {
                symbol: "".to_string(),
                size: 0.0,
                entry_price: price,
                current_price: price,
                unrealized_pnl: 0.0,
                entry_time: Instant::now(),
                last_update: Instant::now(),
            });

            position.current_price = price;
            position.last_update = Instant::now();

            // Calculate unrealized PnL
            if position.size != 0.0 {
                position.unrealized_pnl = (price - position.entry_price) * position.size;
            }

            (position.clone(), position)
        }).await;

        Ok(())
    }

    async fn execute_trade(&mut self, signal: TradingSignal) -> ToolResult<()> {
        if self.config.enable_paper_trading {
            info!("📝 Paper trade executed: {:?}", signal);

            // Update position in paper trading mode
            self.position_processor.update_state(signal.symbol.clone(), |current_position| {
                let mut position = current_position.cloned().unwrap_or(Position {
                    symbol: signal.symbol.clone(),
                    size: 0.0,
                    entry_price: signal.price,
                    current_price: signal.price,
                    unrealized_pnl: 0.0,
                    entry_time: Instant::now(),
                    last_update: Instant::now(),
                });

                match signal.action {
                    TradeAction::Buy => position.size += signal.size,
                    TradeAction::Sell => position.size -= signal.size,
                    TradeAction::Hold => {}, // No position change
                }

                position.entry_price = signal.price;
                position.current_price = signal.price;
                position.last_update = Instant::now();

                (position.clone(), position)
            }).await;

            // Update trading metrics
            let mut metrics = self.metrics.write().await;
            metrics.total_trades += 1;

            info!("✅ Trade executed: {} {} {:.2} @ {:.6}",
                 signal.symbol,
                 match signal.action { TradeAction::Buy => "BUY", TradeAction::Sell => "SELL", TradeAction::Hold => "HOLD" },
                 signal.size,
                 signal.price);
        } else {
            // Real trading would integrate with exchange APIs
            warn!("🚫 Real trading not implemented - enable paper trading mode");
        }

        Ok(())
    }

    async fn update_latency_metrics(&self, latency_ms: f64) {
        let mut metrics = self.metrics.write().await;

        // Simple latency tracking (in production, you'd use proper percentile calculation)
        if metrics.latency_stats.min_latency_ms == 0.0 || latency_ms < metrics.latency_stats.min_latency_ms {
            metrics.latency_stats.min_latency_ms = latency_ms;
        }
        if latency_ms > metrics.latency_stats.max_latency_ms {
            metrics.latency_stats.max_latency_ms = latency_ms;
        }

        // Update running average
        let total_events = metrics.processed_events as f64;
        metrics.latency_stats.avg_latency_ms =
            (metrics.latency_stats.avg_latency_ms * (total_events - 1.0) + latency_ms) / total_events;
    }

    pub async fn get_metrics(&self) -> TradingMetrics {
        self.metrics.read().await.clone()
    }

    pub async fn get_flow_stats(&self) -> (usize, usize) {
        self.flow_controller.get_stats().await
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing for high-frequency logging
    tracing_subscriber::fmt()
        .with_env_filter("info,hft_bot=debug,riglr_streams=info")
        .init();

    info!("🚀 Starting High-Frequency Trading Bot");

    // Load configuration
    let config = Config::from_env();
    config.validate()?;

    // Create HFT bot configuration
    let hft_config = HFTConfig {
        enable_paper_trading: true,
        max_orders_per_second: 1000,
        min_order_size: 1.0,
        ..Default::default()
    };

    // Create HFT bot instance
    let mut hft_bot = HFTBot::new(hft_config);

    info!("⚡ HFT Bot initialized - starting price stream processing");

    // Simulate high-frequency price updates
    let symbols = vec!["SOL/USDC", "BTC/USDC", "ETH/USDC"];
    let mut price_generators = HashMap::new();

    // Initialize price generators for each symbol
    for symbol in &symbols {
        price_generators.insert(symbol.clone(), PriceGenerator::new(symbol, 100.0));
    }

    let start_time = Instant::now();
    let mut total_events = 0u64;

    // Performance monitoring
    let mut metrics_interval = tokio::time::interval(Duration::from_secs(10));
    let mut strategy_update_interval = tokio::time::interval(Duration::from_secs(30));

    // Main processing loop
    loop {
        tokio::select! {
            _ = metrics_interval.tick() => {
                let metrics = hft_bot.get_metrics().await;
                let (queue_size, drops) = hft_bot.get_flow_stats().await;

                info!("📊 Performance Metrics:");
                info!("   Events processed: {} (queue: {}, drops: {})", metrics.processed_events, queue_size, drops);
                info!("   Total trades: {} (win rate: {:.1}%)", metrics.total_trades, metrics.win_rate * 100.0);
                info!("   Latency: avg={:.2}ms, min={:.2}ms, max={:.2}ms",
                     metrics.latency_stats.avg_latency_ms,
                     metrics.latency_stats.min_latency_ms,
                     metrics.latency_stats.max_latency_ms);

                let elapsed = start_time.elapsed();
                let rate = total_events as f64 / elapsed.as_secs_f64();
                info!("   Processing rate: {:.0} events/sec", rate);
            }

            _ = strategy_update_interval.tick() => {
                let metrics = hft_bot.get_metrics().await;
                info!("🔧 Updating strategy parameters based on performance");

                // In a real implementation, you'd update strategy parameters
                // based on recent performance metrics
            }

            // Generate price updates at high frequency
            _ = tokio::time::sleep(Duration::from_millis(1)) => {
                // Generate price updates for random symbols
                let symbol = &symbols[fastrand::usize(0..symbols.len())];
                if let Some(generator) = price_generators.get_mut(symbol) {
                    let price_update = generator.next_price();

                    if let Err(e) = hft_bot.process_price_event(price_update).await {
                        if !matches!(e, ToolError::Retriable(_)) {
                            error!("Failed to process price event: {}", e);
                        }
                    } else {
                        total_events += 1;
                    }
                }
            }
        }

        // Stop after reasonable test duration
        if start_time.elapsed() > Duration::from_secs(120) {
            info!("⏰ Test duration complete");
            break;
        }
    }

    // Final metrics report
    let final_metrics = hft_bot.get_metrics().await;
    info!("🏁 Final Performance Report:");
    info!("   Total events: {}", final_metrics.processed_events);
    info!("   Total trades: {}", final_metrics.total_trades);
    info!("   Average latency: {:.2}ms", final_metrics.latency_stats.avg_latency_ms);

    Ok(())
}

/// Price generator for simulation
struct PriceGenerator {
    symbol: String,
    current_price: f64,
    last_update: Instant,
}

impl PriceGenerator {
    fn new(symbol: &str, initial_price: f64) -> Self {
        Self {
            symbol: symbol.to_string(),
            current_price: initial_price,
            last_update: Instant::now(),
        }
    }

    fn next_price(&mut self) -> PriceUpdate {
        // Simulate realistic price movement (geometric brownian motion)
        let dt = self.last_update.elapsed().as_secs_f64();
        let volatility = 0.2; // 20% annual volatility
        let drift = 0.05; // 5% annual drift

        let random_change = (fastrand::f64() - 0.5) * 2.0; // -1 to 1
        let price_change = self.current_price * (drift * dt + volatility * random_change * dt.sqrt());

        self.current_price += price_change;
        self.current_price = self.current_price.max(0.01); // Prevent negative prices

        let now = Instant::now();
        self.last_update = now;

        // Simulate bid/ask spread
        let spread = self.current_price * 0.001; // 0.1% spread
        let bid = self.current_price - spread / 2.0;
        let ask = self.current_price + spread / 2.0;

        PriceUpdate {
            symbol: self.symbol.clone(),
            price: self.current_price,
            volume: fastrand::f64() * 1000.0 + 100.0,
            timestamp: now,
            bid: Some(bid),
            ask: Some(ask),
            spread: Some(spread),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_hft_bot_creation() {
        let config = HFTConfig::default();
        let bot = HFTBot::new(config);

        let metrics = bot.get_metrics().await;
        assert_eq!(metrics.processed_events, 0);
        assert_eq!(metrics.total_trades, 0);
    }

    #[test]
    fn test_mean_reversion_strategy() {
        let mut strategy = MeanReversionStrategy::new(5, 2.0);
        let prices = vec![
            PriceUpdate { symbol: "TEST".to_string(), price: 100.0, volume: 1000.0, timestamp: Instant::now(), bid: None, ask: None, spread: None },
            PriceUpdate { symbol: "TEST".to_string(), price: 101.0, volume: 1000.0, timestamp: Instant::now(), bid: None, ask: None, spread: None },
            PriceUpdate { symbol: "TEST".to_string(), price: 102.0, volume: 1000.0, timestamp: Instant::now(), bid: None, ask: None, spread: None },
            PriceUpdate { symbol: "TEST".to_string(), price: 110.0, volume: 1000.0, timestamp: Instant::now(), bid: None, ask: None, spread: None }, // Outlier
        ];

        let positions = HashMap::new();
        let signal = strategy.generate_signal(&prices, &positions);

        // Should generate a sell signal due to high price
        if let Some(signal) = signal {
            matches!(signal.action, TradeAction::Sell);
        }
    }

    #[tokio::test]
    async fn test_risk_manager() {
        let limits = RiskLimits::default();
        let risk_manager = RiskManager::new(limits);

        let signal = TradingSignal {
            symbol: "TEST".to_string(),
            action: TradeAction::Buy,
            size: 100.0,
            price: 50.0,
            confidence: 0.8,
            strategy: "test".to_string(),
            timestamp: Instant::now(),
        };

        let positions = HashMap::new();
        let is_valid = risk_manager.validate_trade(&signal, &positions).await;
        assert!(is_valid);
    }

    #[test]
    fn test_price_generator() {
        let mut generator = PriceGenerator::new("BTC/USD", 50000.0);
        let price1 = generator.next_price();
        let price2 = generator.next_price();

        assert_eq!(price1.symbol, "BTC/USD");
        assert!(price1.price > 0.0);
        assert!(price1.bid.is_some());
        assert!(price1.ask.is_some());
        assert_ne!(price1.price, price2.price); // Prices should change
    }
}