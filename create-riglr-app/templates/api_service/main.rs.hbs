//! {{project_name}} - {{description}}
//!
//! API Service Backend powered by RIGLR framework

use anyhow::Result;
use std::sync::Arc;
use tracing::{info, error};
use riglr_config::Config;
use riglr_core::provider::ApplicationContext;
use riglr_agents::{
    agents::tool_calling::{ToolCallingAgentBuilder, DebuggableCompletionModel},
    toolset::Toolset,
    registry::LocalAgentRegistry,
    dispatcher::AgentDispatcher,
    Agent,
};
use rig::client::CompletionClient;
use rig::providers::anthropic::Client as AnthropicClient;

mod routes;
mod middleware;

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "{{project_name}}=info,riglr=info".into())
        )
        .init();

    info!("Starting {{project_name}} API Service");

    // Load configuration using riglr-config
    dotenvy::dotenv().ok();
    let config = Config::from_env();
    config.validate()?;
    
    info!("Configuration loaded and validated");

    // Set up ApplicationContext for dependency injection
    let app_context = Arc::new(ApplicationContext::from_config(&config));

    // Inject necessary clients as extensions
    {{#if has_solana}}
    // Create and inject Solana RPC client
    let solana_client = Arc::new(solana_client::rpc_client::RpcClient::new(
        config.network.solana_rpc_url.clone().unwrap_or_else(|| "https://api.mainnet-beta.solana.com".to_string())
    ));
    app_context.set_extension(solana_client);
    info!("Solana RPC client initialized");
    {{/if}}

    {{#if has_evm}}
    // Create and inject EVM Provider
    use alloy::providers::ProviderBuilder;
    if let Some(rpc_url) = config.network.get_rpc_url("1") {
        let provider = ProviderBuilder::new()
            .on_http(rpc_url.parse()?)
            .boxed();
        app_context.set_extension(provider);
        info!("EVM provider initialized");
    }
    {{/if}}

    {{#if has_web_tools}}
    // Create and inject API clients for web tools
    let api_clients = riglr_web_tools::client::ApiClients::from_config(&config.providers);
    app_context.set_extension(Arc::new(api_clients));
    info!("Web tools API clients initialized");
    {{/if}}

    {{#if has_redis}}
    // Initialize Redis connection pool
    let redis_url = std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
    let redis_client = redis::Client::open(redis_url)?;
    app_context.set_extension(Arc::new(redis_client));
    info!("Redis connection established");
    {{/if}}

    {{#if has_database}}
    // Initialize database connection
    let database_url = std::env::var("DATABASE_URL")?;
    let db_pool = sqlx::postgres::PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    app_context.set_extension(Arc::new(db_pool));
    info!("Database connection established");
    {{/if}}

    // Create AI agent using the new architecture
    let agent = create_agent(app_context.clone()).await?;
    info!("AI agent initialized");

    // Set up agent registry and dispatcher
    let registry = Arc::new(LocalAgentRegistry::new());
    registry.register_agent(agent).await?;
    let dispatcher = Arc::new(AgentDispatcher::new(registry));
    info!("Agent dispatcher initialized");

    // Create app state for the web server
    let app_state = AppState {
        config: app_context.config.clone(),
        app_context: app_context.clone(),
        dispatcher,
    };

    // Start server
    let host = std::env::var("HOST").unwrap_or_else(|_| "0.0.0.0".to_string());
    let port: u16 = std::env::var("PORT")
        .unwrap_or_else(|_| "8080".to_string())
        .parse()?;

    info!("Starting server on http://{}:{}", host, port);

    {{#if (eq server_framework "axum")}}
    use axum::Router;
    use std::net::SocketAddr;
    
    let app = Router::new()
        .nest("/api/v1", routes::create_routes())
        .with_state(Arc::new(app_state));

    let addr: SocketAddr = format!("{}:{}", host, port).parse()?;
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    
    axum::serve(listener, app).await?;
    {{/if}}

    {{#if (eq server_framework "actix")}}
    use actix_web::{web, App, HttpServer};
    
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .service(web::scope("/api/v1").configure(routes::configure))
    })
    .bind(format!("{}:{}", host, port))?
    .run()
    .await?;
    {{/if}}

    {{#if (eq server_framework "warp")}}
    use warp::Filter;
    
    let routes = routes::create_routes(Arc::new(app_state));
    warp::serve(routes)
        .run(([0, 0, 0, 0], port))
        .await;
    {{/if}}

    {{#if (eq server_framework "rocket")}}
    use rocket::State;
    
    rocket::build()
        .manage(Arc::new(app_state))
        .mount("/api/v1", routes::create_routes())
        .launch()
        .await?;
    {{/if}}

    Ok(())
}

async fn create_agent(app_context: Arc<ApplicationContext>) -> Result<Arc<dyn Agent>> {
    // 1. Discover all available tools
    let mut toolset = Toolset::default();
    
    {{#if has_solana}}
    toolset = toolset.with_solana_tools();
    {{/if}}
    
    {{#if has_evm}}
    toolset = toolset.with_evm_tools();
    {{/if}}
    
    {{#if has_web_tools}}
    toolset = toolset.with_web_tools();
    {{/if}}

    // 2. Create the LLM "brain"
    let anthropic_client = AnthropicClient::new(
        app_context.config.providers.anthropic_api_key.as_ref()
            .expect("ANTHROPIC_API_KEY must be set")
    );
    let model = anthropic_client.completion_model("claude-3-5-sonnet-20240620");
    let debuggable_model = DebuggableCompletionModel::new(model);

    // 3. Build the agent
    let agent = ToolCallingAgentBuilder::new(toolset, app_context)
        .build(debuggable_model)
        .await?;

    Ok(agent)
}

#[derive(Clone)]
struct AppState {
    config: Arc<riglr_config::Config>,
    app_context: Arc<ApplicationContext>,
    dispatcher: Arc<AgentDispatcher>,
}