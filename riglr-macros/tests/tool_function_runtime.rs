//! Comprehensive runtime tests for function-based tools generated by #[tool] macro
//!
//! This test suite covers:
//! - Tool instantiation and metadata
//! - Successful execution paths
//! - Parameter parsing error handling
//! - Application logic error handling
//! - Both async and sync functions

use riglr_core::{JobResult, Tool};
use riglr_macros::{tool, IntoToolError};
use serde_json::json;
use thiserror::Error;

// Test error enum for comprehensive error handling tests
#[derive(Error, Debug, IntoToolError)]
enum TestError {
    #[error("Network timeout occurred")]
    NetworkTimeout, // Should be automatically classified as retriable

    #[error("Invalid input: {message}")]
    InvalidInput { message: String }, // Should be automatically classified as permanent

    #[error("RPC error: {code}")]
    RpcError { code: i32 }, // Should be automatically classified as retriable

    #[error("Insufficient balance: need {required}, have {available}")]
    InsufficientBalance { required: u64, available: u64 }, // Should be automatically classified as permanent

    #[tool_error(retriable)]
    #[error("Custom error that should be retriable")]
    CustomRetriable, // Explicitly retriable

    #[tool_error(permanent)]
    #[error("Network issue that should not be retried")]
    NetworkPermanent, // Override default network = retriable

    #[tool_error(rate_limited)]
    #[error("API quota exceeded")]
    ApiQuotaExceeded, // Rate limited
}

// Test functions with various signatures and behaviors

/// Test function with no parameters
#[tool]
async fn no_params_fn() -> Result<String, TestError> {
    Ok("success".to_string())
}

/// Test synchronous function with parameters
#[tool(description = "A sync function that doubles a number")]
fn sync_params_fn(a: i32) -> Result<i32, TestError> {
    Ok(a * 2)
}

/// Function with only doc comment for description
/// This function demonstrates doc comment extraction
#[tool]
async fn doc_comment_fn() -> Result<&'static str, TestError> {
    Ok("documented")
}

#[tool]
async fn no_description_fn() -> Result<&'static str, TestError> {
    Ok("no_desc")
}

/// Function that can return different error types based on input
#[tool]
async fn error_fn(mode: String) -> Result<String, TestError> {
    match mode.as_str() {
        "network_timeout" => Err(TestError::NetworkTimeout),
        "invalid_input" => Err(TestError::InvalidInput {
            message: "bad data".to_string(),
        }),
        "rpc_error" => Err(TestError::RpcError { code: 500 }),
        "insufficient_balance" => Err(TestError::InsufficientBalance {
            required: 1000,
            available: 500,
        }),
        "custom_retriable" => Err(TestError::CustomRetriable),
        "network_permanent" => Err(TestError::NetworkPermanent),
        "api_quota" => Err(TestError::ApiQuotaExceeded),
        _ => Ok("success".to_string()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test 1.2.2: Test Tool Instantiation and Metadata

    #[test]
    fn test_tool_convenience_functions_exist() {
        // Verify that the _tool() convenience functions exist and return Arc<dyn Tool>
        let tool1 = no_params_fn_tool();
        let tool2 = sync_params_fn_tool();
        let tool3 = doc_comment_fn_tool();
        let tool4 = no_description_fn_tool();
        let tool5 = error_fn_tool();

        // Check they are the right type
        assert_eq!(tool1.name(), "no_params_fn");
        assert_eq!(tool2.name(), "sync_params_fn");
        assert_eq!(tool3.name(), "doc_comment_fn");
        assert_eq!(tool4.name(), "no_description_fn");
        assert_eq!(tool5.name(), "error_fn");
    }

    #[test]
    fn test_tool_struct_instantiation() {
        // Verify that the generated Tool structs can be created with ::new() and Default
        let tool1 = no_params_fn::Tool::new();
        let tool2 = sync_params_fn::Tool;

        assert_eq!(tool1.name(), "no_params_fn");
        assert_eq!(tool2.name(), "sync_params_fn");
    }

    #[test]
    fn test_tool_names() {
        // Test that tool.name() returns the correct function identifier
        let tool1 = no_params_fn::Tool::new();
        let tool2 = sync_params_fn::Tool::new();
        let tool3 = doc_comment_fn::Tool::new();

        assert_eq!(tool1.name(), "no_params_fn");
        assert_eq!(tool2.name(), "sync_params_fn");
        assert_eq!(tool3.name(), "doc_comment_fn");
    }

    #[test]
    fn test_tool_descriptions() {
        // Test description extraction from different sources
        let tool_with_attr = sync_params_fn::Tool::new();
        let tool_with_doc = doc_comment_fn::Tool::new();
        let tool_no_desc = no_description_fn::Tool::new();

        assert_eq!(
            tool_with_attr.description(),
            "A sync function that doubles a number"
        );
        assert_eq!(tool_with_doc.description(), "Function with only doc comment for description\nThis function demonstrates doc comment extraction");
        assert_eq!(tool_no_desc.description(), "");
    }

    // Test 1.2.3: Test execute() Success Paths

    #[tokio::test]
    async fn test_execute_no_params_success() {
        let tool = no_params_fn::Tool::new();
        let result = tool.execute(json!({})).await.unwrap();

        match result {
            JobResult::Success { value, tx_hash } => {
                assert_eq!(value, json!("success"));
                assert_eq!(tx_hash, None);
            }
            _ => panic!("Expected Success, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_execute_sync_params_success() {
        let tool = sync_params_fn::Tool::new();
        let result = tool.execute(json!({"a": 5})).await.unwrap();

        match result {
            JobResult::Success { value, tx_hash } => {
                assert_eq!(value, json!(10));
                assert_eq!(tx_hash, None);
            }
            _ => panic!("Expected Success, got {:?}", result),
        }
    }

    // Test 1.2.4: Test execute() Failure Paths

    #[tokio::test]
    async fn test_execute_parameter_parsing_errors() {
        let tool = sync_params_fn::Tool::new();

        // Test missing required field
        let result = tool.execute(json!({})).await.unwrap();
        match result {
            JobResult::Failure { error, retriable } => {
                assert!(!retriable);
                assert!(error.contains("Failed to parse parameters"));
            }
            _ => panic!("Expected Failure, got {:?}", result),
        }

        // Test wrong type
        let result = tool.execute(json!({"a": "not_a_number"})).await.unwrap();
        match result {
            JobResult::Failure { error, retriable } => {
                assert!(!retriable);
                assert!(error.contains("Failed to parse parameters"));
            }
            _ => panic!("Expected Failure, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_execute_application_logic_errors() {
        let tool = error_fn::Tool::new();

        // Test retriable errors
        let retriable_cases = vec![
            ("network_timeout", "Network timeout occurred"),
            ("rpc_error", "RPC error: 500"),
            ("custom_retriable", "Custom error that should be retriable"),
        ];

        for (mode, expected_msg) in retriable_cases {
            let result = tool.execute(json!({"mode": mode})).await.unwrap();
            match result {
                JobResult::Failure { error, retriable } => {
                    assert!(retriable, "Expected retriable error for mode: {}", mode);
                    assert!(
                        error.contains(expected_msg),
                        "Expected error message '{}' not found in '{}'",
                        expected_msg,
                        error
                    );
                }
                _ => panic!("Expected Failure for mode: {}, got {:?}", mode, result),
            }
        }

        // Test permanent errors
        let permanent_cases = vec![
            ("invalid_input", "Invalid input: bad data"),
            (
                "insufficient_balance",
                "Insufficient balance: need 1000, have 500",
            ),
            (
                "network_permanent",
                "Network issue that should not be retried",
            ),
        ];

        for (mode, expected_msg) in permanent_cases {
            let result = tool.execute(json!({"mode": mode})).await.unwrap();
            match result {
                JobResult::Failure { error, retriable } => {
                    assert!(!retriable, "Expected permanent error for mode: {}", mode);
                    assert!(
                        error.contains(expected_msg),
                        "Expected error message '{}' not found in '{}'",
                        expected_msg,
                        error
                    );
                }
                _ => panic!("Expected Failure for mode: {}, got {:?}", mode, result),
            }
        }

        // Test rate limited error
        let result = tool.execute(json!({"mode": "api_quota"})).await.unwrap();
        match result {
            JobResult::Failure { error, retriable } => {
                assert!(retriable);
                assert!(error.contains("Rate limited"));
                assert!(error.contains("API quota exceeded"));
            }
            _ => panic!("Expected Failure for api_quota, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_successful_execution_path() {
        let tool = error_fn::Tool::new();
        let result = tool.execute(json!({"mode": "success"})).await.unwrap();

        match result {
            JobResult::Success { value, tx_hash } => {
                assert_eq!(value, json!("success"));
                assert_eq!(tx_hash, None);
            }
            _ => panic!("Expected Success, got {:?}", result),
        }
    }
}
