//! Comprehensive runtime tests for struct-based tools generated by #[tool] macro
//! 
//! This test suite covers:
//! - Tool instantiation and metadata for structs
//! - Successful execution paths  
//! - Parameter parsing error handling
//! - Application logic error handling using struct-based tools

use riglr_macros::{tool, IntoToolError};
use riglr_core::Tool;
use std::sync::Arc;
use thiserror::Error;
use serde::{Serialize, Deserialize};
use schemars::JsonSchema;

// Reuse the TestError enum from function tests
#[derive(Error, Debug, IntoToolError)]
enum TestError {
    #[error("Network timeout occurred")]
    NetworkTimeout,
    
    #[error("Invalid input: {message}")]
    InvalidInput { message: String },
    
    #[error("RPC error: {code}")]
    RpcError { code: i32 },
    
    #[error("Insufficient balance")]
    InsufficientBalance,
    
    #[tool_error(retriable)]
    #[error("Custom retriable error")]
    CustomRetriable,
    
    #[tool_error(permanent)]
    #[error("Custom permanent error")]
    CustomPermanent,
    
    #[tool_error(rate_limited)]
    #[error("API quota exceeded")]
    ApiQuotaExceeded,
}

// Test struct tools

/// Struct tool that always succeeds
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool]
struct SuccessToolStruct {
    /// Input message to process
    pub message: String,
    /// Optional multiplier
    #[serde(default = "default_multiplier")]
    pub multiplier: Option<u32>,
}

fn default_multiplier() -> Option<u32> {
    Some(1)
}

impl SuccessToolStruct {
    pub async fn execute(&self) -> Result<String, TestError> {
        let mult = self.multiplier.unwrap_or(1);
        Ok(format!("Processed: {} (x{})", self.message, mult))
    }
}

/// Struct tool that can produce various errors based on field values  
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool]
struct ErrorToolStruct {
    /// Error mode to trigger
    pub error_mode: String,
    /// Optional error code
    pub error_code: Option<i32>,
}

impl ErrorToolStruct {
    pub async fn execute(&self) -> Result<String, TestError> {
        match self.error_mode.as_str() {
            "network_timeout" => Err(TestError::NetworkTimeout),
            "invalid_input" => Err(TestError::InvalidInput { 
                message: "bad struct data".to_string() 
            }),
            "rpc_error" => Err(TestError::RpcError { 
                code: self.error_code.unwrap_or(500) 
            }),
            "insufficient_balance" => Err(TestError::InsufficientBalance),
            "custom_retriable" => Err(TestError::CustomRetriable),
            "custom_permanent" => Err(TestError::CustomPermanent),
            "api_quota" => Err(TestError::ApiQuotaExceeded),
            _ => Ok("struct success".to_string()),
        }
    }
}

/// Struct with no doc comments or description attribute
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool]
struct NoDescToolStruct {
    pub value: i32,
}

impl NoDescToolStruct {
    pub async fn execute(&self) -> Result<i32, TestError> {
        Ok(self.value * 2)
    }
}

/// Struct with explicit description attribute
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool(description = "Tool struct with explicit description")]
struct DescAttrToolStruct {
    pub name: String,
}

impl DescAttrToolStruct {
    pub async fn execute(&self) -> Result<String, TestError> {
        Ok(format!("Hello, {}", self.name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test 1.3.2: Test Tool Instantiation and Metadata

    #[test]
    fn test_struct_as_tool_convenience_method() {
        // Verify the as_tool() convenience method exists and works correctly
        let success_struct = SuccessToolStruct {
            message: "test".to_string(),
            multiplier: Some(2),
        };
        
        let tool: Arc<dyn Tool> = success_struct.as_tool();
        assert_eq!(tool.name(), "SuccessToolStruct");
    }

    #[test]
    fn test_struct_tool_names() {
        // Test that tool.name() returns the correct struct identifier
        let success_tool = SuccessToolStruct {
            message: "test".to_string(),
            multiplier: None,
        };
        
        let error_tool = ErrorToolStruct {
            error_mode: "none".to_string(),
            error_code: None,
        };
        
        assert_eq!(success_tool.name(), "SuccessToolStruct");
        assert_eq!(error_tool.name(), "ErrorToolStruct");
    }

    #[test]
    fn test_struct_tool_descriptions() {
        // Test description for all description scenarios
        let no_desc_tool = NoDescToolStruct { value: 42 };
        let desc_attr_tool = DescAttrToolStruct { name: "test".to_string() };
        
        assert_eq!(no_desc_tool.description(), "");
        assert_eq!(desc_attr_tool.description(), "Tool struct with explicit description");
    }

    // Test 1.3.3: Test execute() Success Path

    #[tokio::test]
    async fn test_struct_execute_success() {
        let tool = SuccessToolStruct {
            message: "hello".to_string(),
            multiplier: Some(2),
        };
        
        let result = tool.execute().await.unwrap();
        
        assert_eq!(result, "Processed: hello (x2)");
    }

    #[tokio::test]
    async fn test_struct_execute_with_defaults() {
        let tool = SuccessToolStruct {
            message: "hello".to_string(),
            multiplier: None,
        };
        
        let result = tool.execute().await.unwrap();
        
        assert_eq!(result, "Processed: hello (x1)");
    }

    // Test 1.3.4: Test execute() Failure Paths

    #[tokio::test]
    async fn test_struct_execute_error_handling() {
        // For struct tools, the "parameters" are the struct fields themselves
        // So we test error conditions by calling the error tool
        let tool = ErrorToolStruct {
            error_mode: "network_timeout".to_string(),
            error_code: Some(500),
        };
        
        let result = tool.execute().await;
        
        // This should return an error from the struct's execute method
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_struct_different_error_modes() {
        // Test retriable error
        let retriable_tool = ErrorToolStruct {
            error_mode: "network_timeout".to_string(),
            error_code: None,
        };
        
        let result = retriable_tool.execute().await;
        assert!(result.is_err());
        
        // Test permanent error  
        let permanent_tool = ErrorToolStruct {
            error_mode: "invalid_input".to_string(),
            error_code: Some(400),
        };
        
        let result = permanent_tool.execute().await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_struct_successful_execution_path() {
        let tool = ErrorToolStruct {
            error_mode: "success".to_string(),
            error_code: None,
        };
        
        let result = tool.execute().await.unwrap();
        
        assert_eq!(result, "struct success");
    }
}
