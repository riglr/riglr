//! Comprehensive runtime tests for struct-based tools generated by #[tool] macro
//! 
//! This test suite covers:
//! - Tool instantiation and metadata for structs
//! - Successful execution paths  
//! - Parameter parsing error handling
//! - Application logic error handling using struct-based tools

use riglr_macros::{tool, IntoToolError};
use riglr_core::{Tool, JobResult, ToolError};
use serde_json::json;
use std::sync::Arc;
use thiserror::Error;
use serde::{Serialize, Deserialize};
use schemars::JsonSchema;

// Reuse the TestError enum from function tests
#[derive(Error, Debug, IntoToolError)]
enum TestError {
    #[error("Network timeout occurred")]
    NetworkTimeout,
    
    #[error("Invalid input: {message}")]
    InvalidInput { message: String },
    
    #[error("RPC error: {code}")]
    RpcError { code: i32 },
    
    #[error("Insufficient balance")]
    InsufficientBalance,
    
    #[tool_error(retriable)]
    #[error("Custom retriable error")]
    CustomRetriable,
    
    #[tool_error(permanent)]
    #[error("Custom permanent error")]
    CustomPermanent,
    
    #[tool_error(rate_limited)]
    #[error("API quota exceeded")]
    ApiQuotaExceeded,
}

// Test struct tools

/// Struct tool that always succeeds
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool]
struct SuccessToolStruct {
    /// Input message to process
    pub message: String,
    /// Optional multiplier
    #[serde(default = "default_multiplier")]
    pub multiplier: Option<u32>,
}

fn default_multiplier() -> Option<u32> {
    Some(1)
}

impl SuccessToolStruct {
    pub async fn execute(&self) -> Result<String, TestError> {
        let mult = self.multiplier.unwrap_or(1);
        Ok(format!("Processed: {} (x{})", self.message, mult))
    }
}

/// Struct tool that can produce various errors based on field values  
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool]
struct ErrorToolStruct {
    /// Error mode to trigger
    pub error_mode: String,
    /// Optional error code
    pub error_code: Option<i32>,
}

impl ErrorToolStruct {
    pub async fn execute(&self) -> Result<String, TestError> {
        match self.error_mode.as_str() {
            "network_timeout" => Err(TestError::NetworkTimeout),
            "invalid_input" => Err(TestError::InvalidInput { 
                message: "bad struct data".to_string() 
            }),
            "rpc_error" => Err(TestError::RpcError { 
                code: self.error_code.unwrap_or(500) 
            }),
            "insufficient_balance" => Err(TestError::InsufficientBalance),
            "custom_retriable" => Err(TestError::CustomRetriable),
            "custom_permanent" => Err(TestError::CustomPermanent),
            "api_quota" => Err(TestError::ApiQuotaExceeded),
            _ => Ok("struct success".to_string()),
        }
    }
}

/// Struct with no doc comments or description attribute
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool]
struct NoDescToolStruct {
    pub value: i32,
}

impl NoDescToolStruct {
    pub async fn execute(&self) -> Result<i32, TestError> {
        Ok(self.value * 2)
    }
}

/// Struct with explicit description attribute
#[derive(Serialize, Deserialize, JsonSchema, Clone)]
#[tool(description = "Tool struct with explicit description")]
struct DescAttrToolStruct {
    pub name: String,
}

impl DescAttrToolStruct {
    pub async fn execute(&self) -> Result<String, TestError> {
        Ok(format!("Hello, {}", self.name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test 1.3.2: Test Tool Instantiation and Metadata

    #[test]
    fn test_struct_as_tool_convenience_method() {
        // Verify the as_tool() convenience method exists and works correctly
        let success_struct = SuccessToolStruct {
            message: "test".to_string(),
            multiplier: Some(2),
        };
        
        let tool: Arc<dyn Tool> = success_struct.as_tool();
        assert_eq!(tool.name(), "SuccessToolStruct");
    }

    #[test]
    fn test_struct_tool_names() {
        // Test that tool.name() returns the correct struct identifier
        let success_tool = SuccessToolStruct {
            message: "test".to_string(),
            multiplier: None,
        };
        
        let error_tool = ErrorToolStruct {
            error_mode: "none".to_string(),
            error_code: None,
        };
        
        assert_eq!(success_tool.name(), "SuccessToolStruct");
        assert_eq!(error_tool.name(), "ErrorToolStruct");
    }

    #[test]
    fn test_struct_tool_descriptions() {
        // Test description for all description scenarios
        let no_desc_tool = NoDescToolStruct { value: 42 };
        let desc_attr_tool = DescAttrToolStruct { name: "test".to_string() };
        
        assert_eq!(no_desc_tool.description(), "");
        assert_eq!(desc_attr_tool.description(), "Tool struct with explicit description");
    }

    // Test 1.3.3: Test execute() Success Path

    #[tokio::test]
    async fn test_struct_execute_success() {
        let tool = SuccessToolStruct {
            message: "test message".to_string(),
            multiplier: Some(3),
        };
        
        let result = tool.execute(json!({
            "message": "hello",
            "multiplier": 2
        })).await.unwrap();
        
        match result {
            JobResult::Success { value, tx_hash } => {
                assert_eq!(value, json!("Processed: hello (x2)"));
                assert_eq!(tx_hash, None);
            }
            _ => panic!("Expected Success, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_struct_execute_with_defaults() {
        let tool = SuccessToolStruct {
            message: "default test".to_string(),
            multiplier: None,
        };
        
        let result = tool.execute(json!({
            "message": "hello"
        })).await.unwrap();
        
        match result {
            JobResult::Success { value, tx_hash } => {
                assert_eq!(value, json!("Processed: hello (x1)"));
                assert_eq!(tx_hash, None);
            }
            _ => panic!("Expected Success, got {:?}", result),
        }
    }

    // Test 1.3.4: Test execute() Failure Paths

    #[tokio::test]
    async fn test_struct_parameter_parsing_errors() {
        let tool = SuccessToolStruct {
            message: "test".to_string(),
            multiplier: None,
        };
        
        // Test missing required field
        let result = tool.execute(json!({
            "multiplier": 2
            // missing "message" field
        })).await.unwrap();
        
        match result {
            JobResult::Failure { error, retriable } => {
                assert!(!retriable);
                assert!(error.contains("Failed to parse parameters"));
            }
            _ => panic!("Expected Failure, got {:?}", result),
        }
        
        // Test wrong type
        let result = tool.execute(json!({
            "message": "hello",
            "multiplier": "not_a_number"
        })).await.unwrap();
        
        match result {
            JobResult::Failure { error, retriable } => {
                assert!(!retriable);
                assert!(error.contains("Failed to parse parameters"));
            }
            _ => panic!("Expected Failure, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_struct_application_logic_errors() {
        let tool = ErrorToolStruct {
            error_mode: "test".to_string(),
            error_code: None,
        };
        
        // Test retriable errors
        let retriable_cases = vec![
            ("network_timeout", None, "Network timeout occurred"),
            ("rpc_error", Some(404), "RPC error: 404"),
            ("custom_retriable", None, "Custom retriable error"),
        ];
        
        for (mode, code, expected_msg) in retriable_cases {
            let input = if let Some(c) = code {
                json!({"errorMode": mode, "errorCode": c})
            } else {
                json!({"errorMode": mode})
            };
            
            let result = tool.execute(input).await.unwrap();
            match result {
                JobResult::Failure { error, retriable } => {
                    assert!(retriable, "Expected retriable error for mode: {}", mode);
                    assert!(error.contains(expected_msg), "Expected error message '{}' not found in '{}'", expected_msg, error);
                }
                _ => panic!("Expected Failure for mode: {}, got {:?}", mode, result),
            }
        }
        
        // Test permanent errors
        let permanent_cases = vec![
            ("invalid_input", "Invalid input: bad struct data"),
            ("insufficient_balance", "Insufficient balance"),
            ("custom_permanent", "Custom permanent error"),
        ];
        
        for (mode, expected_msg) in permanent_cases {
            let result = tool.execute(json!({"errorMode": mode})).await.unwrap();
            match result {
                JobResult::Failure { error, retriable } => {
                    assert!(!retriable, "Expected permanent error for mode: {}", mode);
                    assert!(error.contains(expected_msg), "Expected error message '{}' not found in '{}'", expected_msg, error);
                }
                _ => panic!("Expected Failure for mode: {}, got {:?}", mode, result),
            }
        }
        
        // Test rate limited error
        let result = tool.execute(json!({"errorMode": "api_quota"})).await.unwrap();
        match result {
            JobResult::Failure { error, retriable } => {
                assert!(retriable);
                assert!(error.contains("Rate limited"));
                assert!(error.contains("API quota exceeded"));
            }
            _ => panic!("Expected Failure for api_quota, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_struct_successful_execution_path() {
        let tool = ErrorToolStruct {
            error_mode: "success".to_string(),
            error_code: None,
        };
        
        let result = tool.execute(json!({"errorMode": "success"})).await.unwrap();
        
        match result {
            JobResult::Success { value, tx_hash } => {
                assert_eq!(value, json!("struct success"));
                assert_eq!(tx_hash, None);
            }
            _ => panic!("Expected Success, got {:?}", result),
        }
    }
}
