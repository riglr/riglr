# Tour of Your First Agent

This comprehensive guide walks you through every file generated by `create-riglr-app`, explaining how each component works and how to extend your agent with custom tools.

## What Gets Generated

After running `create-riglr-app`, your project will have the following structure:

```
my-trading-bot/
â”œâ”€â”€ Cargo.toml           # Dependencies and project metadata
â”œâ”€â”€ .env.example         # Environment variables template
â”œâ”€â”€ chains.toml          # Multi-chain configuration
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs          # Application entry point
â”‚   â”œâ”€â”€ tools/           # Your custom tools
â”‚   â”‚   â””â”€â”€ mod.rs       # Tool exports
â”‚   â””â”€â”€ agents/          # Agent definitions
â”‚       â””â”€â”€ mod.rs       # Agent exports
â””â”€â”€ tests/               # Integration tests
    â””â”€â”€ integration.rs   # Basic test harness
```

## Deep Dive: Understanding Each File

### 1. The Entry Point (`main.rs`)

Your `main.rs` file is the heart of your application. Let's examine what it does:

```rust
use anyhow::Result;
use riglr_config::Config;
use riglr_core::provider::ApplicationContext;
use riglr_core::signer_context::SignerContext;
use riglr_solana_tools::SolanaRpcClient;
use std::sync::Arc;

mod tools;
mod agents;

#[tokio::main]
async fn main() -> Result<()> {
    // 1. Load unified configuration from environment
    let config = Config::from_env();
    
    // 2. Create ApplicationContext from the config
    let app_context = ApplicationContext::from_config(&config);
    
    // 3. Add blockchain-specific clients as extensions
    if let Some(solana_rpc) = config.network.solana_rpc_url.as_ref() {
        let client = Arc::new(SolanaRpcClient::new(solana_rpc.clone()));
        app_context.set_extension(client);
    }
    
    // 4. Initialize the appropriate mode based on CLI arguments
    let args = parse_args();
    
    match args.mode {
        Mode::Interactive => run_interactive(app_context, config).await?,
        Mode::Server => run_server(app_context, config).await?,
        Mode::Worker => run_worker(app_context, config).await?,
    }
    
    Ok(())
}
```

**Key Points:**
- The application uses the unified `riglr_config::Config` system
- Configuration is loaded from environment variables with fail-fast validation
- `ApplicationContext` is created from the config, providing dependency injection
- Different modes (interactive, server, worker) are supported out of the box
- Error handling uses `anyhow::Result` for simplicity

### 2. Configuration Management (Unified riglr-config)

riglr uses a unified configuration system provided by the `riglr-config` crate. This eliminates the need for custom configuration files and provides a standardized way to configure your application.

```rust
// Configuration is loaded in main.rs using:
let config = Config::from_env();

// Access configuration values throughout your application:
println!("Redis URL: {}", config.database.redis_url);
println!("Environment: {:?}", config.app.environment);

// Get RPC URLs for different chains:
if let Some(rpc_url) = config.network.get_rpc_url("ethereum") {
    println!("Ethereum RPC: {}", rpc_url);
}

// Access provider configurations:
if let Some(openai_key) = &config.providers.openai_api_key {
    // Use OpenAI API key
}
```

**Configuration Structure:**
```
Config
â”œâ”€â”€ app: ApplicationConfig (server settings, transaction defaults)
â”œâ”€â”€ database: DatabaseConfig (Redis, Neo4j, ClickHouse)
â”œâ”€â”€ network: NetworkConfig (RPC URLs, chain contracts)
â”œâ”€â”€ providers: ProvidersConfig (AI, blockchain data providers)
â””â”€â”€ features: FeaturesConfig (feature flags)
```

**Key Points:**
- Unified configuration loaded from environment variables
- Fail-fast validation catches errors at startup
- Type-safe access to all configuration values
- Supports multi-chain configurations with dynamic RPC URLs
- No custom configuration code needed

### 3. The Tools Directory (`tools/mod.rs`)

The `tools/` directory is where you define custom capabilities for your agent. Let's look at the structure:

```rust
// tools/mod.rs
use riglr_macros::tool;
use riglr_core::{ToolError, ApplicationContext};
use serde::{Deserialize, Serialize};

// Re-export tools from other modules
pub mod price_monitor;
pub mod portfolio;
pub mod trading;

pub use price_monitor::*;
pub use portfolio::*;
pub use trading::*;

// Example: A simple price checking tool
#[tool]
/// Gets the current price of a token from multiple sources
async fn get_token_price(
    /// The token symbol (e.g., "SOL", "ETH")
    symbol: String,
    /// The blockchain network ("solana", "ethereum", "polygon")
    network: String,
    context: &ApplicationContext,
) -> Result<TokenPrice, ToolError> {
    // The context provides access to shared dependencies
    let price_client = context.get_extension::<Arc<PriceClient>>()
        .map_err(|_| ToolError::permanent_string("Price client not configured"))?;
    
    // Fetch price with automatic retry on transient failures
    let price = price_client
        .get_price(&symbol, &network)
        .await
        .map_err(|e| {
            // Classify errors for intelligent retry behavior
            match e {
                PriceError::NetworkTimeout => ToolError::retriable_string(e.to_string()),
                PriceError::RateLimited => ToolError::rate_limited_string(e.to_string()),
                PriceError::InvalidSymbol => ToolError::invalid_input_string(e.to_string()),
                _ => ToolError::permanent_string(e.to_string()),
            }
        })?;
    
    Ok(TokenPrice {
        symbol,
        network,
        price_usd: price,
        timestamp: chrono::Utc::now(),
    })
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TokenPrice {
    pub symbol: String,
    pub network: String,
    pub price_usd: f64,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}
```

**Key Points:**
- Tools are annotated with `#[tool]` macro for automatic rig integration
- Doc comments become tool descriptions for the AI model
- `ApplicationContext` provides dependency injection
- Error classification enables intelligent retry behavior
- Tools return strongly-typed results

### 4. Agent Definitions (`agents/mod.rs`)

Agents combine your tools with AI models to create intelligent behavior:

```rust
// agents/mod.rs
use rig::agent::{Agent, AgentBuilder};
use rig::providers::openai::Client as OpenAIClient;
use riglr_core::provider::ApplicationContext;
use crate::tools;

pub struct TradingAgent {
    agent: Agent,
    context: Arc<ApplicationContext>,
}

impl TradingAgent {
    pub fn new(config: &Config, context: Arc<ApplicationContext>) -> Result<Self> {
        // Initialize the AI model from config
        let api_key = config.providers.openai_api_key.as_ref()
            .ok_or_else(|| anyhow::anyhow!("OpenAI API key not configured"))?;
        let client = OpenAIClient::new(api_key);
        let model = client.model("gpt-4-turbo-preview");
        
        // Build the agent with tools
        let agent = AgentBuilder::new(model)
            .preamble("You are a sophisticated DeFi trading assistant...")
            .tool(tools::get_token_price_tool())
            .tool(tools::analyze_market_tool())
            .tool(tools::execute_swap_tool())
            .tool(tools::monitor_position_tool())
            .temperature(0.7)
            .max_tokens(2000)
            .build();
        
        Ok(Self { agent, context })
    }
    
    pub async fn process_request(&self, prompt: &str) -> Result<String> {
        // The agent will automatically select and use appropriate tools
        let response = self.agent
            .prompt(prompt)
            .await
            .map_err(|e| anyhow::anyhow!("Agent error: {}", e))?;
        
        Ok(response)
    }
    
    pub async fn run_interactive(&self) -> Result<()> {
        use std::io::{self, Write};
        
        println!("ðŸ¤– Trading Agent Ready! Type 'exit' to quit.\n");
        
        loop {
            print!("You: ");
            io::stdout().flush()?;
            
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            
            let input = input.trim();
            if input == "exit" {
                break;
            }
            
            println!("\nAgent: Thinking...");
            match self.process_request(input).await {
                Ok(response) => println!("Agent: {}\n", response),
                Err(e) => println!("Error: {}\n", e),
            }
        }
        
        Ok(())
    }
}
```

**Key Points:**
- Agents encapsulate AI models with your custom tools
- The preamble sets the agent's behavior and personality
- Tools are automatically selected based on the user's request
- Temperature and token limits control response generation

## Next Steps

You now have a solid understanding of the project structure generated by `create-riglr-app`. The next logical step is to build your own custom tool and integrate it into your agent.

- **Continue to the next tutorial: [Building Your First Custom Tool](../tutorials/building-your-first-tool.md)**